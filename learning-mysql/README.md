# 数据结构

[演示地址](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

- 二叉树（Binary Search Trees）

  **如果数据很长，遍历数据就要从头到尾查找，耗时**

- 红黑树（平衡二叉树）

  为了解决耗时将数据平衡，但是：

  **1、每次都要检查规则，再把树进行重新平衡，这个是非常消耗时间的**

  **2、数据量大的话，红黑树的深度会比较深，树一旦深就代表着我们读取磁盘次数就会增加**

- B树

  **特点 1：一个节点里面多了几个子节点**

  **特点2：多个子节点数值都是从左到右排序**

  **特点3：叶节点具有相同的深度，保证了每个数值查询效率一致**

  **特点4：每个节点里面都包含具体信息data**

  > 为了降低树的高度，但是子节点太多，内存有限，不能随便设置子节点。详细如下解释：
  >
  > 这里就涉及到计算机原理的知识了，用通俗的图表示一下
  >
  >  
  >
  >   ![34071ebbd0dfa3bca9ea74a822e972fb.png](https://img-blog.csdnimg.cn/img_convert/34071ebbd0dfa3bca9ea74a822e972fb.png) 
  >
  > **读取数据流程主要交给磁头和磁盘**，我们的数据存放在每个扇区中，要读取一个扇区数据，需要把**磁头移动到相应的磁道**上面，然后**磁盘快速旋转，从而读取到里面值**。(详细知识自行度娘)
  >
  > 整个过程磁头寻道是比较慢的，我们与硬盘的交互尽量减少寻道这个动作
  >
  > **上面小伙伴有个疑问**，我们能否扩大树节点中的子节点数，甚至只有一个根节点就行了。这个是不行的，因为小伙伴们不要忘了，**内存也是有限的，**所有数据存储在一个根节点中，数据量一旦上亿就吃不消了。
  >
  > 其实本质还有一个基本知识就是**【磁盘有预读机制，每次读的时候都是加载一个磁盘页到内存里面】**，这话的理解就是一次磁盘I/o读取只能读一个**磁盘页大小(4kb)**的数据到内存中，也就是8kb的数据，要磁盘i/o的2次操作。
  >
  > 就是因为这个磁盘预读机制，也就是不可能树的节点随便我们设置，应该树节点的数据量正好是一个磁盘页的大小，这样**效率最高**，一次IO读取一个树节点。

- B+树

  去掉子节点中的data数据，而且子节点之间增加指针

  [**问：为什么官方建议使用自增长主键作为索引。**]()

  结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率

# 回表查询



# explain分析

explain通常用于查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，让我们能清楚的分析sql是否需要进行优化

**使用方法：**

​     再查询语句的前面加上 EXPLAIN就OK啦！例如：

 

![img](https://img-blog.csdnimg.cn/20190219144908280.png)

 

- **id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.**

  (1) id相同时，执行顺序由上至下

  (2) 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行

  (3)id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行

- **select_type: SELECT 查询的类型**

​    (1) SIMPLE(简单SELECT,不使用UNION或子查询等)

​    (2) PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)

​    (3) UNION(UNION中的第二个或后面的SELECT语句)

​    (4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)

​    (5) UNION RESULT(UNION的结果)

​    (6) SUBQUERY(子查询中的第一个SELECT)

​    (7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)

​    (8) DERIVED(派生表的SELECT, FROM子句的子查询)

​    (9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

- **table: 查询的是哪个表**
- **partitions: 匹配的分区**
- t**ype: join 类型**

​    常用的类型有： ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）

​    (1) ALL：进行了全表扫描。

​    (2) index: 全索引扫描。

​    (3) range:有范围的索引扫描。相对于index的全索引扫描，它有范围限制，因此要优于index。关于range比较容易理解，需要记住的是出现了range，则一定是基于索引的。同时除了显而易见的between，and以及'>','<'外，in和or也是索引范围扫描。

​    (4) ref:  查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复. 这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。

​    (5) eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件

​    (6) const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system

​    (7) NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引

- **possible_keys: MySQL能使用哪个索引在该表中找到行**
- **key: 此次查询中确切使用到的索引.**
- **ref: 显示使用哪个列或常数与key一起从表中选择行。**
- **rows: 显示此查询一共扫描了多少行. 这个是一个估计值.**
- **extra: 额外的信息**