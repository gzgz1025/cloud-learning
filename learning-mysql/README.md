# 数据结构

[演示地址](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

- 二叉树（Binary Search Trees）

  **如果数据很长，遍历数据就要从头到尾查找，耗时**

- 红黑树（平衡二叉树）

  为了解决耗时将数据平衡，但是：

  **1、每次都要检查规则，再把树进行重新平衡，这个是非常消耗时间的**

  **2、数据量大的话，红黑树的深度会比较深，树一旦深就代表着我们读取磁盘次数就会增加**

- B树

  **特点 1：一个节点里面多了几个子节点**

  **特点2：多个子节点数值都是从左到右排序**

  **特点3：叶节点具有相同的深度，保证了每个数值查询效率一致**

  **特点4：每个节点里面都包含具体信息data**

  > 为了降低树的高度，但是子节点太多，内存有限，不能随便设置子节点。详细如下解释：
  >
  > 这里就涉及到计算机原理的知识了，用通俗的图表示一下
  >
  >  
  >
  >   ![34071ebbd0dfa3bca9ea74a822e972fb.png](https://img-blog.csdnimg.cn/img_convert/34071ebbd0dfa3bca9ea74a822e972fb.png) 
  >
  > **读取数据流程主要交给磁头和磁盘**，我们的数据存放在每个扇区中，要读取一个扇区数据，需要把**磁头移动到相应的磁道**上面，然后**磁盘快速旋转，从而读取到里面值**。(详细知识自行度娘)
  >
  > 整个过程磁头寻道是比较慢的，我们与硬盘的交互尽量减少寻道这个动作
  >
  > **上面小伙伴有个疑问**，我们能否扩大树节点中的子节点数，甚至只有一个根节点就行了。这个是不行的，因为小伙伴们不要忘了，**内存也是有限的，**所有数据存储在一个根节点中，数据量一旦上亿就吃不消了。
  >
  > 其实本质还有一个基本知识就是**【磁盘有预读机制，每次读的时候都是加载一个磁盘页到内存里面】**，这话的理解就是一次磁盘I/o读取只能读一个**磁盘页大小(4kb)**的数据到内存中，也就是8kb的数据，要磁盘i/o的2次操作。
  >
  > 就是因为这个磁盘预读机制，也就是不可能树的节点随便我们设置，应该树节点的数据量正好是一个磁盘页的大小，这样**效率最高**，一次IO读取一个树节点。

- B+树

  去掉子节点中的data数据，而且子节点之间增加指针

  [**问：为什么官方建议使用自增长主键作为索引。**]()

  结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率